
import type { NextApiRequest, NextApiResponse } from 'next'
import formidable, { File } from 'formidable'
import fs from 'fs'
import crypto from 'crypto'
import zlib from 'zlib'

export const config = { api: { bodyParser: false } }

function sha256(buf: Buffer): string {
  return crypto.createHash('sha256').update(buf).digest('hex')
}

// Canonicalize: normalize EOL to LF, strip trailing spaces, ensure utf8
function canonicalize(input: Buffer): Buffer {
  let txt = input.toString('utf8')
  txt = txt.replace(/\r\n/g, '\n').replace(/\r/g, '\n')
  txt = txt.split('\n').map(line => line.replace(/[\t ]+$/g,'')).join('\n')
  return Buffer.from(txt, 'utf8')
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') return res.status(405).json({ ok:false, message: 'Method not allowed' })
  try {
    const form = formidable({ multiples: false })
    const { fields, files } = await new Promise<{fields: formidable.Fields; files: formidable.Files}>((resolve, reject)=>{
      form.parse(req, (err, fields, files) => err ? reject(err) : resolve({fields, files}))
    })

    const f = files.file as File
    if (!f || Array.isArray(f)) return res.status(400).json({ ok:false, message: 'Missing file' })

    const original = await fs.promises.readFile(f.filepath)
    const canon = canonicalize(original)
    const canonHash = sha256(canon)
    const originalHash = sha256(original)

    const compressed = zlib.deflateSync(canon)
    const compressedHash = sha256(compressed)

    const stages = [
      { name: 'ORIGINAL', bytes: original.length, sha256: originalHash },
      { name: 'CANON',    bytes: canon.length,    sha256: canonHash },
      { name: 'PACK(zlib)', bytes: compressed.length, sha256: compressedHash }
    ]

    const ratio = compressed.length / Math.max(1, canon.length)
    const certificate_id = canonHash  // canonical id == canon sha256

    const cert = {
      version: 'CSL-CERT/1.0',
      theorem: fields.theorem || undefined,
      stages,
      compression: { algo: 'zlib', ratio, bytes_before: canon.length, bytes_after: compressed.length },
      issued_at: new Date().toISOString(),
      certificate_id
    }

    const certJson = Buffer.from(JSON.stringify(cert, null, 2), 'utf8')
    const certB64 = certJson.toString('base64')
    const certName = `${certificate_id}.cslx.json`

    return res.status(200).json({ ok:true, cert, certFileBase64: certB64, certFileName: certName })
  } catch (e:any) {
    console.error(e)
    return res.status(500).json({ ok:false, message: e?.message || 'Internal error' })
  }
}
